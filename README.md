# BOJ 17611 직각다각형

이 문서는 단순직각다각형에서 **가장 많은 교차 횟수를 갖는 수평선(H) 또는 수직선(V)** 을 찾아 그 값을 출력하는 문제(BOJ 17611)의 풀이 아이디어를 정리한 리드미다. 추후 복습을 위해 작성한다.

---

## 문제 요약

단순직각다각형의 꼭짓점 N개가 주어지고, 변들은 모두 x축 혹은 y축에 평행하다.
우리가 찾고자 하는 것은:

* 어떤 y = c 형태의 수평선 H가 **수직선분과 교차하는 횟수의 최댓값 h**
* 어떤 x = c 형태의 수직선 V가 **수평선분과 교차하는 횟수의 최댓값 v**

단, H는 다각형의 수평선분 위에 놓이면 안 되고, V도 수직선분 위에 놓이면 안 된다.
출력은 **max(h, v)**.

---

## 핵심 아이디어

정수 좌표 범위가 -500000 ~ 500000 이므로 총 1000001개의 좌표 라인이 존재한다.
이때 교차 횟수를 효율적으로 세기 위해 **차분 배열(Difference Array)** + **누적합(Prefix Sum)** 을 활용한다.

### 1. 수직선분/수평선분 판별

입력된 꼭짓점 목록 `vec`에 대해 인접한 두 점을 비교한다.

```cpp
if (vec[i].first == vec[i-1].first) {
    // 수직선분
} else {
    // 수평선분
}
```

수직선분이면 y 범위를 기준으로 `vy[]` 배열에,
수평선분이면 x 범위를 기준으로 `vx[]` 배열에 차분값을 기록한다.

---

## 차분 배열을 이용한 교차 횟수 계산

예를 들어 수직선분이 y1 ~ y2 구간을 지나면,

```
vy[y1] += 1
vy[y2] -= 1
```

이후 `vy[]`에 대해 누적합을 수행하면
각 y 위치에서 수평선 H가 교차하는 수직선분 개수가 된다.

코드에서는 좌표를 0 이상 인덱스로 매핑하기 위해 `+500000` 을 해 주었다.

```cpp
vy[vec[i-1].second + 500000]++;
vy[vec[i].second + 500000]--;
```

수평선분도 동일하게 `vx[]` 배열에서 처리한다.

---

## 닫힌 다각형이므로 마지막 점–첫 점도 처리

다각형은 끝이 다시 처음과 연결되므로,
마지막 정점 `vec[N-1]`과 `vec[0]` 사이의 선분도 같은 방식으로 처리한다.

```cpp
if (vec[0].first == vec[N-1].first) {
    // 수직선분
} else {
    // 수평선분
}
```

---

## 누적합으로 최댓값 찾기

```cpp
int p1 = vy[0];
int p2 = vx[0];
for (int i = 1; i < 1000001; i++) {
    mx = max(mx, max(p1, p2));
    p1 += vy[i];
    p2 += vx[i];
}
```

`p1`, `p2`는 각각 y축과 x축 기준의 현재 교차 횟수이다.
전체 범위를 훑으면서 `mx` 에 최댓값을 저장한다.

결과적으로 `mx = max(h, v)` 가 된다.

---

## 알고리즘 복잡도

* 정점 입력 및 분류: O(N)
* 차분 배열 채우기: O(N)
* 누적합: O(1e6)
* 전체 시간 복잡도: O(N + 1e6)
  (N ≤ 100000 이므로 충분히 빠르다)

메모리도 vx, vy 각각 1000001 크기 int 배열이므로 약 8MB로 충분하다.

---

## 핵심 정리

1. 직각다각형이므로 변은 수직 또는 수평뿐이다.
2. 각 변은 x 또는 y 방향의 "구간"이므로 차분 배열로 교차 횟수를 기록할 수 있다.
3. 수평선이 교차하는 것은 **수직선분에서 y축 방향 구간**,
   수직선이 교차하는 것은 **수평선분에서 x축 방향 구간**이다.
4. 누적합을 통해 모든 y, x 위치에서 교차 횟수를 계산 후 최댓값을 찾는다.
